---
title: "60HN: CRE burden at admission and discharge"
number-sections: true
format:
  html:
    toc: true
    toc-depth: 4
editor: source
editor_options: 
  chunk_output_type: console
#bibliography: references.bib
#csl: the-american-naturalist.csl
---

```{r include = FALSE, eval = FALSE}
knitr::purl("malarone.qmd", "tmp.R", documentation = FALSE)
source("tmp.R")
file.remove("tmp.R")

add_nojekyll <- function() {
  file <- ".nojekyll"
  file.create(file)
  gert::git_add(file)
  gert::git_commit("Adding the .nojekyll file")
  gert::git_push()
}
```

```{r include = FALSE}
par2 <- function(...) par(..., mgp = c(1.5, .5, 0), bty = "n")

knitr::knit_hooks$set(
  margin1 = function(before, options, envir) {
    if (before) par2(plt = c(.105, .97, .15, .95)) else NULL
  })

eps <- .8
knitr::opts_chunk$set(margin1    = TRUE,
                      fig.retina = 2,
                      fig.align  = "center",
                      fig.height = eps * 5, # default is 5
                      fig.width  = eps * 7) # default is 7 and maximum possible is 8.3
```


## Constants

The folder that contains the data files:

```{r}
path2data <- paste0("/Users/", Sys.getenv("USER"), "/Library/CloudStorage/",
                    "OneDrive-OxfordUniversityClinicalResearchUnit/",
                    "GitHub/choisy/60HN/")
```

```{r include = FALSE}
path2cache <- paste0(path2data, "cache/")
if (! dir.exists(path2cache)) dir.create(path2cache)
make_path <- function(x) paste0(path2cache, x)
file_exists <- function(x) file.exists(make_path(x))
readRDS2 <- function(x) readRDS(make_path(x))
saveRDS2 <- function(object, file) saveRDS(object, make_path(file))
```

The name of the file that contains the discharge dates of the patients that did not
provide samples at discharge:

```{r}
discharge_file <- "60HN - DischargeDate_no_discharge_sample_27Nov25.xlsx"
```

The name of the CRF data file:

```{r}
CRF_file <- "25-11-2025-_60HN_PATIENT_P1_Data.xls"
```

The name of the MALDI-TOF data file:

```{r}
MALDITOF_file <- paste0("60HN_LAB_ID_20251014_merged_Blue and",
                        " pink_confirmed by Maldi-TOF.xlsx")
```

Number of minutes per day:

```{r}
mpd <- 1440
```


## Packages

Required packages:

```{r}
required <- c("readxl", "purrr", "dplyr", "lubridate", "magrittr", "tidyr", "msm",
              "rlang")
```

Installing those that are not installed yet:

```{r}
to_install <- required[! required %in% installed.packages()[,"Package"]]
if (length(to_install)) install.packages(to_install)
```

Loading the packages for interactive use:

```{r warning = FALSE, message = FALSE}
invisible(sapply(required, library, character.only = TRUE))
```


## General functions

A function that pastes a vector of dates and a vector of times both in character format
and returns a  `dttm` vector:

```{r}
as_datetime2 <- function(date, time) {
  as_datetime2_ <- function(date, time) {
    if (is.na(date)) return(NA)
    if (is.na(time)) time <- "12:00:00"    # if only time is missing, we fix it to noon
    as_datetime(paste(date, time))
  }
  map2_vec(date, time, as_datetime2_)
}
```

A function that converts a column `col` of a data frame `x` into a list-column
(assuming that all the other columns have the same values across rows):

```{r}
col2listcol <- function(x, col) {
  x |> 
    select(- {{ col }}) |> 
    head(1) |> 
    bind_cols(tibble("{{col}}" := list(pull(x, {{ col }}))))
}
```

A tuning of the `hist()` function:

```{r}
hist2 <- function(x, ...) hist(x, floor(min(x)):ceiling(max(x)), ...)
```

A wrapper that formats the output of the `binom.test()` function:

```{r}
binom_test <- function(x, n, ...) {
  if (n < 1) return(c(estimate = NA, lower = NA, upper = NA))
  binom.test(x, n, ...) |> 
    magrittr::extract(c("estimate", "conf.int")) |> 
    unlist() |> 
    setNames(c("estimate", "lower", "upper"))
}
```

A tuning of the `polygon()` function:

```{r}
polygon2 <- function(x, y1, y2, ...) polygon(c(x, rev(x)), c(y1, rev(y2)), ...)
```

Utility functions to convert coordinates to make a stairs plot style:

```{r}
x_transform <- function(x) c(x[1], rep(x[-1], each = 2))
y_transform <- function(y) c(rep(head(y, -1), each = 2), last(y))
```

A function that returns the indexes of the first values of consecutive NAs of a vector:

```{r}
firstNA <- function(x) {
  y <- which(is.na(x))
  z <- diff(y) == 1
  if (any(z)) return(y[-(which(z) + 1)])
  y
}
```

Example use:

```{r}
firstNA(c(1, 3, 2, 5, 3, NA, NA, 3, 2, 5, NA, 5, 3, 2, 6, NA, NA, NA, 1, 3, 2, 5, 3))
```

A function that duplicates the first rows of a series of rows with NA values in the
`colNA` column, and replaces the values of the `col_sel` columns with values of the
row right before:

```{r}
duplicate_NA_rows <- function(x, colNA = "estimate",
                              col_sel = c("denominator", "numerator", "estimate",
                                          "lower", "upper")) {
  x <- mutate(x, .id = row_number())
  NA_ind <- firstNA(x[[colNA]])
  duplicates <- x[NA_ind, ]
  duplicates[, col_sel] <- x[NA_ind - 1, col_sel]
  duplicates |>
    bind_rows(x) |> 
    arrange(.id) |> 
    select(-.id)
}
```

A function that splits a data frame `x` into a list of data frames according to the
presence of missing values in the `col` column of the data frame:

```{r}
remove_NAs <- function(x, col) {
  x |> 
    mutate(col1 = as.numeric(is.na({{ col }})),
           col2 = cumsum(col1)) |> 
    na.exclude() |> 
    group_by(col2) |> 
    group_split()
}
```

Example use:

```{r}
carbs <- mtcars$carb
carbs[c(8, 20:25)] <- NA
mtcars$carb <- carbs
remove_NAs(mtcars, carb)
rm(mtcars)
```

A tuning of the `msm()` function for a bi-state bi-directional case:

```{r}
bsm <- function(formula, subject, data, ...) {
  output <- do.call(msm::msm, c(list(formula = formula,
                                     subject = substitute(subject),
                                     data    = data,
                                     qmatrix = matrix(c(0:1, 1:0), 2)), list(...)))
  output$call <- match.call()
  output
}
```

A function that bootstraps estimates of the fitted multistate model `msm_fit` where `f`
is the function that generates the estimates and `N` is the number of bootstrap
repetitions:

```{r}
boot_msm <- function(msm_fit, f = qmatrix.msm, N = 1000, ...) {
  msm_fit |>
    boot.msm(function(x) f(x)$estimates, N, ...) |> 
    unlist() |> 
    array(dim = c(dim(msm_fit$Qmatrices$baseline), N))
}
```

A function that generates statistic `f` estimates from bootstrap samples `boot_samples`
outputed by `boot_msm()`:

```{r}
boot_stat <- function(boots_samples, f = sd) {
  output <- apply(boots_samples, 1:2, f)
  mat_names <- paste("State", 1:nrow(output))
  colnames(output) <-  mat_names
  rownames(output) <-  mat_names
  output
}
```

A function that generates a `ci`% confidence interval from bootstrap samples
`boot_samples` outputed by `boot_msm()`:

```{r}
boot_ci <- function(boots_samples, ci = .95) {
  ci <- (1 - ci) / 2
  output <- apply(boots_samples, 1:2, function(x) quantile(x, c(ci, 1 - ci)))
  mat_names <- paste("State", 1:ncol(output))
  dimnames(output) <- list(rownames(output[, , 1]), mat_names, mat_names)
  aperm(output, c(1, 3, 2))
}
```

A function that computes `lubridate`-formatted durations:

```{r}
time_diff <- function(x) as.duration(diff(x))
```


## Discharge dates

Loading the discharge dates for the patients who did not provide any sample at
discharge:

```{r}
(discharge_dates <- paste0(path2data, discharge_file) |>
   read_excel() |> 
   mutate(across(`Discharge date`, ~ .x + hours(12))) |>  # setting time to noon
   select(-No, -SiteID, -`Discharge date (2)`))
```


## CRF data

Reading the data:

```{r eval = FALSE}
file <- paste0(path2data, CRF_file)

sheets <- file |>
  excel_sheets() |> 
  head(-1)

CRF <- sheets |> 
  map(read_excel, path = file) |> 
  setNames(sheets) |> 
  map(~ .x |>  # de-duplication of records
          group_by(USUBJID) |> 
          group_modify(~ .x |>
                           arrange(desc(entry)) |> 
                           first()) |> 
          ungroup())
```

```{r include = FALSE, warning = FALSE}
if (file_exists("CRF.rds")) {
  CRF <- readRDS2("CRF.rds")
} else {
  file <- paste0(path2data, CRF_file)
  sheets <- file |>
    excel_sheets() |> 
    head(-1)
  
  CRF <- sheets |> 
    map(read_excel, path = file) |> 
    setNames(sheets) |> 
    map(~ .x |>  # de-duplication of records
          group_by(USUBJID) |> 
          group_modify(~ .x |>
                         arrange(desc(entry)) |> 
                         first()) |> 
          ungroup())

  saveRDS2(CRF, "CRF.rds")
}
```

### Samples dates {#sec-samples_dates}

The dates of samples collection at admission and discharge:

```{r eval = FALSE}
dates <- CRF |> 
  extract2("SCR") |> 
  select(USUBJID, SPEC_DATE_ADMISSION, SPEC_TIME_ADMISSION,
                  SPEC_DATE_DISCHARGE, SPEC_TIME_DISCHARGE) |> 
  mutate(ADMISSION = as_datetime2(SPEC_DATE_ADMISSION, SPEC_TIME_ADMISSION),
         DISCHARGE = as_datetime2(SPEC_DATE_DISCHARGE, SPEC_TIME_DISCHARGE)) |> 
  select(- SPEC_DATE_ADMISSION, - SPEC_TIME_ADMISSION,
         - SPEC_DATE_DISCHARGE, - SPEC_TIME_DISCHARGE)
```

```{r include = FALSE, warning = FALSE}
if (file_exists("dates.rds")) {
  dates <- readRDS2("dates.rds")
} else {
  dates <- CRF |> 
    extract2("SCR") |> 
    select(USUBJID, SPEC_DATE_ADMISSION, SPEC_TIME_ADMISSION,
                    SPEC_DATE_DISCHARGE, SPEC_TIME_DISCHARGE) |> 
    mutate(ADMISSION = as_datetime2(SPEC_DATE_ADMISSION, SPEC_TIME_ADMISSION),
           DISCHARGE = as_datetime2(SPEC_DATE_DISCHARGE, SPEC_TIME_DISCHARGE)) |> 
    select(- SPEC_DATE_ADMISSION, - SPEC_TIME_ADMISSION,
           - SPEC_DATE_DISCHARGE, - SPEC_TIME_DISCHARGE)
  saveRDS2(dates, "dates.rds")
}
```

which gives:

```{r}
dates
```

The number of missing samples at discharge:

```{r}
(nb_missing_samples <- dates |> 
   filter(is.na(DISCHARGE)) |> 
   nrow())
```

The total number of samples is thus:

```{r}
(nb_samples <- 2 * nrow(dates) - nb_missing_samples)
```

Verifying that `DISCHARGE` is after `ADMISSION`:

```{r}
dates |> 
  na.exclude() |> 
  filter(DISCHARGE < ADMISSION)
```


### Wards

> From Huong:
>
> "I just realize that there is one significant factor that would significantly
contribute the force of infection (colonization) during hospitalization. This is the
fact that patients from the same clinical ward can transmit CRE between one another. 
Therefore it would be best if the model can include the possibility within-ward
transmission versus between within-hospital transmission. The ward type variable can
identify the patients in the same ward or not. I think this should be the first
priority to add."

Generating the ward data:

```{r}
(wards <- CRF$ADM |> 
   mutate(across(starts_with("WARD"), as.numeric),
          ward = paste0(SITEID, WARD_1, WARD_2, WARD_3)) |> 
   arrange(SITEID) |> 
   select(USUBJID, ward))
```

An overview of the number of patients per wards:

```{r}
wards |> 
  group_by(ward) |> 
  tally() |> 
  print(n = Inf)
```


### Enrolled

A function that computes the data for ward occupancy:

```{r}
ward_occupancy <- function(x) {
  f <- function(...) pivot_longer(..., names_to = "change", values_to = "date")
  bind_rows(f(select(x, -DISCHARGE), ADMISSION),
            f(select(x, -ADMISSION), DISCHARGE)) |> 
    arrange(date) |> 
    mutate(across(change, ~ setNames(c(1, -1), c("ADMISSION", "DISCHARGE"))[.x])) |> 
    group_by(date) |> 
    summarise(change = sum(change)) |> 
    ungroup() |> 
    mutate(occupancy = cumsum(change)) |> 
    select(-change)
}
```

A function that plots a ward occupancy:

```{r}
plot_occ <- function(x, y = NULL, ...) {
  x |> 
    first() |> 
    mutate(occupancy = 0) |> 
    bind_rows(x) |> 
    with({
      plot(date, occupancy, type = "n", ...)
      polygon(c(head(date, 2), rep(tail(date, -2), each = 2)),
              c(first(occupancy),
                rep(tail(head(occupancy, -1), -1), each = 2),
                last(occupancy)), col = "grey")
      })
  if (! is.null(y)) abline(v = y, col = "red")
}
```

where `x` is an output from `ward_occupancy()` and `y` is the date of the last
admission of the ward. Putting the ward and dates data together, using
`discharge_dates` for patients who did not provide any sample at discharge (for the
latter, the time is set to noon and, for those who have admission and discharge the
same day with admission in the afternoon, discharge time is then set to one hour after
admission):

```{r}
(ward_dates <- wards |>
   left_join(dates, "USUBJID") |> 
   left_join(discharge_dates, "USUBJID") |> 
   mutate(across(DISCHARGE, ~ if_else(is.na(.x), `Discharge date`, .x)),
          across(DISCHARGE, ~ if_else(as_date(DISCHARGE) == as_date(ADMISSION) &
                                        DISCHARGE < ADMISSION,
                                      ADMISSION + hours(1), DISCHARGE))) |>
   select(- `Discharge date`))
```

Verifying that `DISCHARGE` is after `ADMISSION`:

```{r}
ward_dates |> 
  na.exclude() |> 
  filter(DISCHARGE < ADMISSION)
```

Computing the dates of last admissions for each ward:

```{r}
last_admissions <- ward_dates |> 
  select(-DISCHARGE) |> 
  na.exclude() |> 
  group_by(ward) |> 
  group_modify(~ .x |>
                   arrange(ADMISSION) |>
                   last()) |> 
  ungroup() |> 
  pull(ADMISSION)
```

Computing and plotting the ward occupancies:

```{r occupancies_figure, fig.height = 10.38, fig.width  = 8.3}
#| label: fig-occupancies
#| fig-cap: "Number of patients enrolled as a function of time for each ward. The red vertical line indicates the last enrollment."
opar <- par(mfrow = c(8, 4))
ward_dates |> 
  group_by(ward) |> 
  group_map(~ ward_occupancy(.x), .keep = TRUE) |> 
  walk2(last_admissions, plot_occ, ann = FALSE)
par(opar)
```


### Durations

The distribution of the durations of stay in the wards:

```{r distribution_durations}
#| label: fig-durations_distribution
#| fig-cap: "The distribution of the time spent in the ward."
ward_dates |> 
  mutate(duration = as.numeric(DISCHARGE - ADMISSION) / mpd) |> 
  pull(duration) |> 
  hist2(xlab = "duration of stay (days)", ylab = "number of patients")
```


## MALDI-TOF data

Reading the MALDI-TOF data:

```{r}
(MALDITOF <- path2data |>
  paste0(MALDITOF_file) |>
  read_excel() |> 
  select(USUBJID, SampleSchedule, Identification_MALDITOF)) |> 
  unique()
```

Recoding the isolates that are not identified:

```{r}
unidentified <- c("No organism identification possible", 
                  "No peaks found", "no peaks found")
MALDITOF <- MALDITOF |> 
  mutate(across(Identification_MALDITOF,
                ~ if_else(.x %in% unidentified, "unidentified", .x)))
```

Number of isolates not identified and identified:

```{r}
MALDITOF |> 
  mutate(identification = Identification_MALDITOF != "unidentified") |> 
  group_by(identification) |> 
  tally()
```

The list of positive samples:

```{r}
(MALDITOF_samples <- MALDITOF |> 
   select(- Identification_MALDITOF) |> 
   unique())
```

The number of positive samples:

```{r}
(nb_positive_samples <- nrow(MALDITOF_samples))
```

Which represents `{r} round(100 * nb_positive_samples / nb_samples, 2)` % of
samples. The distribution of bacteria across the samples:

```{r}
MALDITOF |> 
  group_by(Identification_MALDITOF) |> 
  tally() |> 
  mutate(`% +ve smpls` = round(100 * n / nb_positive_samples, 1),
         `% all smpls` = round(100 * n / nb_samples, 1)) |> 
  arrange(desc(n))
```

Let's look at the number of patients that have a sample at discharge only, at 
admission only, and both at admission and discharge:

```{r}
MALDITOF_samples |> 
  mutate(state = 1) |> 
  pivot_wider(names_from = SampleSchedule, values_from = state) |> 
  mutate(across(-USUBJID, ~ ! is.na(.x))) |> 
  group_by(ADMISSION, DISCHARGE) |> 
  tally() |> 
  ungroup()
```

## CRE exposure

### All CRE

The number of enrolled patient with CRE at admission as a function of time for each
ward:

```{r CREoccupancies_figure, fig.height = 10.38, fig.width  = 8.3}
#| label: fig-CREoccupancies
#| fig-cap: "Number of enrolled patients with CRE at admission as a function of time for each ward."
opar <- par(mfrow = c(8, 4))

CRE_admission <- MALDITOF_samples |> 
  filter(SampleSchedule == "ADMISSION") |> 
  pull(USUBJID)

ward_dates |> 
  filter(USUBJID %in% CRE_admission) |> 
  group_by(ward) |> 
  group_map(~ ward_occupancy(.x), .keep = TRUE) |> 
  walk(plot_occ, ann = FALSE)

par(opar)
```

A function that plots the prevalence estimate `estimate` and lower and upper bonds
`lower` and `upper` of the confidence interval from a data frame of a ward:

```{r}
plot_prevalence <- function(x) {
  with(x, plot(x_transform(date), y_transform(estimate),
               type = "n", ann = FALSE, ylim = 0:1))
  x |> 
    duplicate_NA_rows() |> 
    remove_NAs(estimate) |> 
    map(~ with(.x, polygon2(x_transform(date), y_transform(lower), y_transform(upper),
                            col = "grey", border = NA)))
  with(x, lines(x_transform(date), y_transform(estimate)))
}
```

Computing the proportions of CRE positives as a function of time for each ward:

```{r}
numerator_df <- ward_dates |> 
  filter(USUBJID %in% CRE_admission) |> 
  group_by(ward) |> 
  group_modify(~ ward_occupancy(.x)) |> 
  rename(numerator = occupancy)

proportion_CRE <- ward_dates |> 
  group_by(ward) |> 
  group_modify(~ ward_occupancy(.x)) |> 
  ungroup() |> 
  rename(denominator = occupancy) |>
  left_join(numerator_df, c("ward", "date")) |> 
  fill(numerator) |> 
  mutate(across(numerator, ~ replace_na(.x, 0)),
         Clopper_Pearson = map2(numerator, denominator, binom_test)) |> 
  unnest_wider(Clopper_Pearson)
```

Proportion of enrolled patients that are CRE positive at admission as a function of
time for each ward:

```{r CREprevalences_figure, fig.height = 10.38, fig.width  = 8.3}
#| label: fig-CREprevalences
#| fig-cap: "Proportion of enrolled patients that are CRE positive at admission as a function of time for each ward."

opar <- par(mfrow = c(8, 4))
proportion_CRE |> 
  group_by(ward) |> 
  group_walk(~ plot_prevalence(.x))
par(opar)
```


### *K. pneumoniae*

Here we have the same plots as for the previous section but for *K. pneumoniae* only.
First the number of enrolled patient with CRE *K. pneumoniae* at admission as a
function of time for each ward:

```{r Kp_occupancies_figure, fig.height = 10.38, fig.width  = 8.3}
#| label: fig-Kp_occupancies
#| fig-cap: "Number of enrolled patients with CRE *K pneumonia* at admission as a function of time for each ward."
opar <- par(mfrow = c(8, 4))

Kp_admission <- MALDITOF |> 
  filter(SampleSchedule == "ADMISSION",
         Identification_MALDITOF == "Klebsiella pneumoniae") |> 
  pull(USUBJID)

ward_dates |> 
  filter(USUBJID %in% Kp_admission) |> 
  group_by(ward) |> 
  group_map(~ ward_occupancy(.x), .keep = TRUE) |> 
  walk(plot_occ, ann = FALSE)

par(opar)
```

Proportion of enrolled patients that are CRE *K. pneumoniae* positive at admission as a
function of time for each ward:

```{r Kp_prevalences_figure, fig.height = 10.38, fig.width  = 8.3}
#| label: fig-Kp_prevalences
#| fig-cap: "Proportion of enrolled patients that are CRE *K. pneumoniae* positive at admission as a function of time for each ward."

numerator_df <- ward_dates |> 
  filter(USUBJID %in% Kp_admission) |> 
  group_by(ward) |> 
  group_modify(~ ward_occupancy(.x)) |> 
  rename(numerator = occupancy)

opar <- par(mfrow = c(8, 4))

ward_dates |> 
  group_by(ward) |> 
  group_modify(~ ward_occupancy(.x)) |> 
  ungroup() |> 
  rename(denominator = occupancy) |>
  left_join(numerator_df, c("ward", "date")) |> 
  fill(numerator) |> 
  mutate(across(numerator, ~ replace_na(.x, 0)),
         Clopper_Pearson = map2(numerator, denominator, binom_test)) |> 
  unnest_wider(Clopper_Pearson) |> 
  group_by(ward) |> 
  group_walk(~ plot_prevalence(.x))

par(opar)
```


## Specific functions

A function that generates the presence/absence data (coded as 1/2 here) from the output
`x` of the MALDITOF where `id` is the column of `x` that contains the patient ID,
`time_point` is the column of `x` that contains the time point of the sample (e.g.
`ADMISSION` or `DISCHARGE`), `identification` is the column of `x` that contains the
bacteria identified by the MALDITOF and `bacteria` is a vector of characters that
contains the names of the bacteria that we want to test the presence of.

```{r}
presence_abscence <- function(x, id, time_point, identification, bacteria) {
  x |> 
    group_by({{ id }}, {{ time_point }}) |> 
    group_modify(~ col2listcol(.x, {{ identification }})) |> 
    ungroup() |> 
    mutate(state = map_lgl({{ identification }}, ~ any(bacteria %in% .x)) + 1) |>
    select(- {{ identification }}) |> 
    arrange({{ id }}, {{ time_point }})
}
```

The following function adds the samples that were tested negative to the output `x` of
`presence_abscence()` where `y` is the samples dates as generated in
@sec-samples_dates.

```{r}
add_negatives <- function(x, y, id, time_point) {
  tp <- as_name(enquo(time_point))
  y |> 
    pivot_longer(- {{ id }}, names_to = tp) |> 
    left_join(x, c(as_name(enquo(id)), tp)) |> 
    mutate(across(state, ~ replace_na(., 1))) |> 
    na.exclude() # remove the absence of samples
}
```

A function that selects patients from `x` who have samples from at least 2 time points:

```{r}
select2time_points <- function(x, id) {
  id_with_2obs <- x |> 
    pull({{ id }}) |> 
    table() |> 
    is_greater_than(1) |> 
    which() |> 
    names()
  
  filter(x, {{ id }} %in% id_with_2obs)
}
```

where `id` is the column of `x` that contains the patients IDs. A function that
combines state and time data:

```{r}
state_time <- function(state, time, id, admission, discharge, time_point) {
  time |> 
    mutate("{{discharge}}" := as.numeric({{ discharge }} - {{ admission }}) / mpd,
           "{{admission}}" := 0) |> 
    pivot_longer(- {{ id }},
                 names_to = as_name(enquo(time_point)), values_to = "days") |>
    left_join(x = {{ state }}, y = _,
              c(as_name(enquo(id)), as_name(enquo(time_point))))
}
```

The following function puts the 3 above functions together:

```{r}
msm_data <- function(x, y, id, time_point, identification, bacteria,
                     admission, discharge) {
  x |>
    presence_abscence({{ id }}, {{ time_point }}, {{ identification }}, bacteria) |> 
    add_negatives(y, {{ id }}, {{ time_point }}) |> 
    select2time_points({{ id }}) |> 
    state_time(y, {{ id }}, {{ admission }}, {{ discharge }}, {{ time_point }})
}
```


## *K. pneumoniae*

### Preparing the data

Generating the presence/absence of *K. pneumoniae*:

```{r eval = FALSE}
K_pneumoniae_raw <- presence_abscence(MALDITOF, USUBJID, SampleSchedule,
                                      Identification_MALDITOF, "Klebsiella pneumoniae")
```

```{r include = FALSE, warning = FALSE}
if (file_exists("K_pneumoniae_raw.rds")) {
  K_pneumoniae_raw <- readRDS2("K_pneumoniae_raw.rds")
} else {
  K_pneumoniae_raw <- presence_abscence(MALDITOF, USUBJID, SampleSchedule,
                                        Identification_MALDITOF,
                                        "Klebsiella pneumoniae")
  saveRDS2(K_pneumoniae_raw, "K_pneumoniae_raw.rds")
}
```

Which gives:

```{r}
K_pneumoniae_raw
```

Where `1` is absence and `2` is presence. Adding the samples with negative culture:

```{r}
(K_pneumoniae_raw_a <- add_negatives(K_pneumoniae_raw, dates, USUBJID, SampleSchedule))
```

Selecting the patients that have samples from at least 2 time points:

```{r}
(K_pneumoniae <- select2time_points(K_pneumoniae_raw_a, USUBJID))
```

Making the dataset for the multistate modelling:

```{r}
(Kp_msm <- state_time(K_pneumoniae, dates, USUBJID,
                      ADMISSION, DISCHARGE, SampleSchedule))
```

Alternatively, we can do all at once with this function:

```{r eval = FALSE}
Kp_msm <- msm_data(MALDITOF, dates, USUBJID, SampleSchedule, Identification_MALDITOF,
                   "Klebsiella pneumoniae", ADMISSION, DISCHARGE)
```

```{r include = FALSE, warning = FALSE}
if (file_exists("Kp_msm.rds")) {
  Kp_msm <- readRDS2("Kp_msm.rds")
} else {
  Kp_msm <- msm_data(MALDITOF, dates, USUBJID, SampleSchedule, Identification_MALDITOF,
                     "Klebsiella pneumoniae", ADMISSION, DISCHARGE)
  saveRDS2(Kp_msm, "Kp_msm.rds")
}
```

which gives:

```{r}
Kp_msm
```


### Multi-state modelling

Defining the structure of the $Q$ matrix:

```{r}
Q <- rbind(c(0, 1),
           c(1, 0))
```

Initial values of the $Q$ matrix:

```{r}
(Q_crude <- crudeinits.msm(state ~ days, USUBJID, Q, Kp_msm))
```

Fitting a simple model without any covariate:

```{r}
(Kp_msm_fit <- msm(state ~ days, USUBJID, Kp_msm, Q))
```

Or we call simply do:

```{r}
(Kp_msm_fit <- bsm(state ~ days, USUBJID, Kp_msm))
```

Estimated transition intensity $Q$ matrix:

```{r}
qmatrix.msm(Kp_msm_fit)
```

Estimated transition probability $P$ matrix per day:

```{r}
pmatrix.msm(Kp_msm_fit)
```

Estimated mean sojourn times in each transient state:

```{r}
sojourn.msm(Kp_msm_fit)
```

Log-likelihood of the model:

```{r}
logLik(Kp_msm_fit)
```


#### Bootstrapped CIs

Bootstrapping $Q$ estimates (1000 samples, takes 42" in parallel on 11 cores):

```{r eval = FALSE}
q_list <- boot.msm(Kp_msm_fit, function(x) qmatrix.msm(x)$estimates, 1000, cores = 11)
```

```{r include = FALSE, warning = FALSE}
if (file_exists("q_list.rds")) {
  q_list <- readRDS2("q_list.rds")
} else {
  q_list <- boot.msm(Kp_msm_fit, function(x) qmatrix.msm(x)$estimates, 1000, cores = 11)
  saveRDS2(q_list, "q_list.rds")
}
```

Reformating the output into an array of dimension 2, 2, and 1000 (i.e. 2 states and
1000 bootstrap samples):

```{r}
q_array <- array(unlist(q_list), dim = c(2, 2, 1000))
```

Or we can simply do this instead of the above two successive command lines:

```{r eval = FALSE}
q_array <- boot_msm(Kp_msm_fit, qmatrix.msm, 1000, cores = 11)
```

```{r include = FALSE, warning = FALSE}
if (file_exists("q_array.rds")) {
  q_array <- readRDS2("q_array.rds")
} else {
  q_array <- boot_msm(Kp_msm_fit, qmatrix.msm, 1000, cores = 11)
  saveRDS2(q_array, "q_array.rds")
}
```

The bootstrap estimate of the standard deviation:

```{r}
apply(q_array, 1:2, sd)
```

Or, equivalently, in a formatted output:

```{r}
boot_stat(q_array)
```

And with the mean:

```{r}
boot_stat(q_array, mean)
```

Or the median:

```{r}
boot_stat(q_array, median)
```

The bootstrap estimate of the 95% confidence interval:

```{r}
q_array |>
  apply(1:2, function(x) quantile(x, c(.025, .975))) |> 
  aperm(c(1, 3, 2))
```

Or, equivalently, in a formatted output:

```{r}
boot_ci(q_array)
```

#### Covariates

First covariate: the presence of CRE other than *K. pneumoniae* in the individual:

```{r}
other_CRE_at_admission <- MALDITOF |> 
  filter(SampleSchedule == "ADMISSION",
         Identification_MALDITOF != "Klebsiella pneumoniae") |> 
  mutate(otherCRE = TRUE) |> 
  select(USUBJID, otherCRE) |> 
  unique()
```

Second covariate: the mean prevalence of CRE positives in the ward:

```{r}
ward_means <- function(x) {
  total_duration <- time_diff(range(x$date))
  x |> 
    mutate(weight = time_diff(c(date, NA)) / total_duration) |> 
    summarise(across(c(estimate, lower, upper),
                     ~ sum(replace_na(.x, 0) * weight, na.rm = TRUE)))
}

CRE_prevalence_in_ward <- proportion_CRE |> 
  group_by(ward) |> 
  group_modify(~ ward_means(.x)) |> 
  ungroup()
```

Adding these two covariates to the `msm()` input data set:

```{r}
(Kp_msm_cov <- Kp_msm |> 
   left_join(other_CRE_at_admission, "USUBJID") |> 
   left_join(wards, "USUBJID") |> 
   left_join(CRE_prevalence_in_ward, "ward") |> 
   mutate(across(otherCRE, ~ replace_na(.x, FALSE))) |> 
   select(-value))
```


