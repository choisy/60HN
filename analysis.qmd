---
title: "60HN: CRE burden at admission and discharge"
number-sections: true
format:
  html:
    toc: true
    toc-depth: 4
editor: source
editor_options: 
  chunk_output_type: console
#bibliography: references.bib
#csl: the-american-naturalist.csl
---

```{r include = FALSE, eval = FALSE}
run_all <- function() {
  knitr::purl("analysis.qmd", "tmp.R", documentation = FALSE)
  source("tmp.R")
  file.remove("tmp.R")  
}

add_nojekyll <- function() {
  file <- ".nojekyll"
  file.create(file)
  gert::git_add(file)
  gert::git_commit("Adding the .nojekyll file")
  gert::git_push()
  rm(file)
}
```

```{r include = FALSE}
par2 <- function(...) par(..., mgp = c(1.5, .5, 0), bty = "n")

knitr::knit_hooks$set(
  margin1 = function(before, options, envir) {
    if (before) par2(plt = c(.105, .97, .15, .95)) else NULL
  })

eps <- .8
knitr::opts_chunk$set(margin1    = TRUE,
                      fig.retina = 2,
                      fig.align  = "center",
                      fig.height = eps * 5, # default is 5
                      fig.width  = eps * 7) # default is 7 and maximum possible is 8.3
```


## Constants

The folder that contains the data files:

```{r}
path2data <- paste0("/Users/", Sys.getenv("USER"), "/Library/CloudStorage/",
                    "OneDrive-OxfordUniversityClinicalResearchUnit/",
                    "GitHub/choisy/60HN/")
```

```{r include = FALSE}
path2cache <- paste0(path2data, "cache/")
if (! dir.exists(path2cache)) dir.create(path2cache)
make_path <- function(x) paste0(path2cache, x)
file_exists <- function(x) file.exists(make_path(x))
readRDS2 <- function(x) readRDS(make_path(x))
saveRDS2 <- function(object, file) saveRDS(object, make_path(file))
```

The name of the file that contains the discharge dates of the patients that did not
provide samples at discharge:

```{r}
discharge_file <- "60HN - DischargeDate_no_discharge_sample_27Nov25.xlsx"
```

The name of the CRF data file:

```{r}
CRF_file <- "16-12-2025-_60HN_PATIENT_P1_Data.xls"
```

The name of the MALDI-TOF data file:

```{r}
MALDITOF_file <- "60HN_ID_MALDITOF_confirmation_20251128.xlsx"
```

Number of minutes per day:

```{r}
mpd <- 1440
```

The number of cores to use for parallel computing:

```{r}
#nb_cores <- parallel::detectCores() - 1
nb_cores <- 1
```


## Packages

Required packages:

```{r}
required <- c("readxl", "purrr", "dplyr", "lubridate", "magrittr", "tidyr", "msm",
              "rlang", "mgcv", "gratia", "alluvial", "furrr")
```

Installing those that are not installed yet:

```{r}
to_install <- required[! required %in% installed.packages()[,"Package"]]
if (length(to_install)) install.packages(to_install)
```

Loading the packages for interactive use:

```{r warning = FALSE, message = FALSE}
invisible(sapply(required, library, character.only = TRUE))
```

Setting the strategy of the `furrr` package:

```{r}
plan(multisession)
```


## General functions

A function that pastes a vector of dates and a vector of times both in character format
and returns a  `dttm` vector:

```{r}
as_datetime2 <- function(date, time) {
  as_datetime2_ <- function(date, time) {
    if (is.na(date)) return(NA)
    if (is.na(time)) time <- "12:00:00"    # if only time is missing, we fix it to noon
    as_datetime(paste(date, time))
  }
  map2_vec(date, time, as_datetime2_)
}
```

A function that converts a column `col` of a data frame `x` into a list-column
(assuming that all the other columns have the same values across rows):

```{r}
col2listcol <- function(x, col) {
  x |> 
    select(- {{ col }}) |> 
    first() |> 
    bind_cols(tibble("{{col}}" := list(pull(x, {{ col }}))))
}
```

A tuning of the `hist()` function:

```{r}
hist2 <- function(x, ...) hist(x, floor(min(x)):ceiling(max(x)), main = NA, ...)
```

A wrapper that formats the output of the `binom.test()` function:

```{r}
binom_test <- function(x, n, ...) {
  if (n < 1) return(c(estimate = NA, lower = NA, upper = NA))
  binom.test(x, n, ...) |> 
    magrittr::extract(c("estimate", "conf.int")) |> 
    unlist() |> 
    setNames(c("estimate", "lower", "upper"))
}
```

A tuning of the `polygon()` function:

```{r}
polygon2 <- function(x, y1, y2, border = NA, ...) {
  polygon(c(x, rev(x)), c(y1, rev(y2)), border = border, ...)
}
```

Utility functions to convert coordinates to make a stairs plot style:

```{r}
x_transform <- function(x) c(x[1], rep(x[-1], each = 2))
y_transform <- function(y) c(rep(head(y, -1), each = 2), last(y))
```

A function that returns the indexes of the first values of consecutive NAs of a vector:

```{r}
firstNA <- function(x) {
  y <- which(is.na(x))
  z <- diff(y) == 1
  if (any(z)) return(y[-(which(z) + 1)])
  y
}
```

Example use:

```{r}
firstNA(c(1, 3, 2, 5, 3, NA, NA, 3, 2, 5, NA, 5, 3, 2, 6, NA, NA, NA, 1, 3, 2, 5, 3))
```

A function that duplicates the first rows of a series of rows with NA values in the
`colNA` column, and replaces the values of the `col_sel` columns with values of the
row right before:

```{r}
duplicate_NA_rows <- function(x, colNA = "estimate",
                              col_sel = c("denominator", "numerator", "estimate",
                                          "lower", "upper")) {
  x <- mutate(x, .id = row_number())
  NA_ind <- firstNA(x[[colNA]])
  duplicates <- x[NA_ind, ]
  duplicates[, col_sel] <- x[NA_ind - 1, col_sel]
  duplicates |>
    bind_rows(x) |> 
    arrange(.id) |> 
    select(-.id)
}
```

A function that splits a data frame `x` into a list of data frames according to the
presence of missing values in the `col` column of the data frame:

```{r}
remove_NAs <- function(x, col) {
  x |> 
    mutate(col1 = as.numeric(is.na({{ col }})),
           col2 = cumsum(col1)) |> 
    na.exclude() |> 
    group_by(col2) |> 
    group_split()
}
```

Example use:

```{r eval = FALSE}
carbs <- mtcars$carb
carbs[c(8, 20:25)] <- NA
mtcars$carb <- carbs
remove_NAs(mtcars, carb)
rm(mtcars)
```

A tuning of the `msm()` function for a bi-state bi-directional case:

```{r}
bsm <- function(formula, subject, data, ...) {
  output <- do.call(msm::msm, c(list(formula = formula,
                                     subject = substitute(subject),
                                     data    = data,
                                     qmatrix = matrix(c(0:1, 1:0), 2)), list(...)))
  output$call <- match.call()
  output
}
```

A function that bootstraps estimates of the fitted multistate model `msm_fit` where `f`
is the function that generates the estimates and `N` is the number of bootstrap
repetitions:

```{r}
boot_msm <- function(msm_fit, f = qmatrix.msm, N = 1000, ...) {
  msm_fit |>
    boot.msm(function(x) f(x)$estimates, N, ...) |> 
    unlist() |> 
    array(dim = c(dim(msm_fit$Qmatrices$baseline), N))
}
```

A function that generates statistic `f` estimates from bootstrap samples `boot_samples`
outputed by `boot_msm()`:

```{r}
boot_stat <- function(boots_samples, f = sd) {
  output <- apply(boots_samples, 1:2, f)
  mat_names <- paste("State", 1:nrow(output))
  colnames(output) <-  mat_names
  rownames(output) <-  mat_names
  output
}
```

A function that generates a `ci`% confidence interval from bootstrap samples
`boot_samples` outputed by `boot_msm()`:

```{r}
boot_ci <- function(boots_samples, ci = .95) {
  ci <- (1 - ci) / 2
  output <- apply(boots_samples, 1:2, function(x) quantile(x, c(ci, 1 - ci)))
  mat_names <- paste("State", 1:ncol(output))
  dimnames(output) <- list(rownames(output[, , 1]), mat_names, mat_names)
  aperm(output, c(1, 3, 2))
}
```

A function that computes `lubridate`-formatted durations:

```{r}
time_diff <- function(x) as.duration(diff(x))
```

A function that extracts the estimations with 95% CI of the rate of colonization and
decolonization per 100 patient days:

```{r}
bsm_estimations <- function(x, event_names = c("colonization", "clearance")) {
  out <- cbind(matrix(x$estimates.t, 2), x$ci)
  rownames(out) <- event_names
  colnames(out) <- c("estimate", "lower", "upper")
  100 * out
}
```

Tunings of the `alluvial()` function:

```{r}
alluvial2 <- alluvial
b <- body(alluvial2)
b[26] <- NULL
body(alluvial2) <- b

alluvial3 <- function(x, print = TRUE, ...) {
  alluvial2(x[, 1:2], freq = x[[3]], ...)
  if (print) return(x)
}
```

The following function returns the hazard ratio of the covariates (with 95% confidence
intervals) of an output of `msm()`:

```{r}
HR <- function(x) summary(x)$hazard
```


## Discharge dates

Loading the discharge dates for the patients who did not provide any sample at
discharge:

```{r}
(discharge_dates <- paste0(path2data, discharge_file) |>
  read_excel() |> 
  mutate(across(`Discharge date`, ~ .x + hours(12))) |>  # setting time to noon
  select(-No, -SiteID, -`Discharge date (2)`))
```


## CRF data

Reading the data (it takes **1"**):

```{r eval = FALSE}
file <- paste0(path2data, CRF_file)

CRF <- file |>
  excel_sheets() |> 
  head(-1) |> 
  set_names() |> 
  map(read_excel, path = file) |> 
  map(~ filter(.x, entry > 1))
```

```{r include = FALSE, warning = FALSE}
if (file_exists("CRF.rds")) {
  system.time(CRF <- readRDS2("CRF.rds"))
} else {
  file <- paste0(path2data, CRF_file)
  CRF <- file |>
    excel_sheets() |> 
    head(-1) |> 
    set_names() |> 
    map(read_excel, path = file) |> 
    map(~ filter(.x, entry > 1))
  
    saveRDS2(CRF, "CRF.rds")
}
```

### Samples dates {#sec-samples_dates}

The dates of samples collection at admission and discharge (takes **10"**):

```{r eval = FALSE}
dates <- CRF |> 
  extract2("SCR") |> 
  select(USUBJID, SPEC_DATE_ADMISSION, SPEC_TIME_ADMISSION,
                  SPEC_DATE_DISCHARGE, SPEC_TIME_DISCHARGE) |> 
  mutate(ADMISSION = as_datetime2(SPEC_DATE_ADMISSION, SPEC_TIME_ADMISSION),
         DISCHARGE = as_datetime2(SPEC_DATE_DISCHARGE, SPEC_TIME_DISCHARGE)) |> 
  select(- SPEC_DATE_ADMISSION, - SPEC_TIME_ADMISSION,
         - SPEC_DATE_DISCHARGE, - SPEC_TIME_DISCHARGE)
```

```{r include = FALSE, warning = FALSE}
if (file_exists("dates.rds")) {
  dates <- readRDS2("dates.rds")
} else {
  dates <- CRF |> 
    extract2("SCR") |> 
    select(USUBJID, SPEC_DATE_ADMISSION, SPEC_TIME_ADMISSION,
                    SPEC_DATE_DISCHARGE, SPEC_TIME_DISCHARGE) |> 
    mutate(ADMISSION = as_datetime2(SPEC_DATE_ADMISSION, SPEC_TIME_ADMISSION),
           DISCHARGE = as_datetime2(SPEC_DATE_DISCHARGE, SPEC_TIME_DISCHARGE)) |> 
    select(- SPEC_DATE_ADMISSION, - SPEC_TIME_ADMISSION,
           - SPEC_DATE_DISCHARGE, - SPEC_TIME_DISCHARGE)
  saveRDS2(dates, "dates.rds")
}
```

which gives:

```{r}
dates
```

The number of missing samples at discharge:

```{r}
(nb_missing_samples <- dates |> 
  filter(is.na(DISCHARGE)) |> 
  nrow())
```

The number of samples at admission is:

```{r}
(nb_samples_admission <- nrow(dates))
```

The number of samples at discharge is:

```{r}
(nb_samples_discharge <- nb_samples_admission - nb_missing_samples)
```

The total number of samples is:

```{r}
(nb_samples <- nb_samples_admission + nb_samples_discharge)
```


Verifying that `DISCHARGE` is after `ADMISSION`:

```{r}
dates |> 
  na.exclude() |> 
  filter(DISCHARGE < ADMISSION)
```


### Wards {#sec-wards}

> From Huong:
>
> "I just realize that there is one significant factor that would significantly
contribute the force of infection (colonization) during hospitalization. This is the
fact that patients from the same clinical ward can transmit CRE between one another. 
Therefore it would be best if the model can include the possibility within-ward
transmission versus between within-hospital transmission. The ward type variable can
identify the patients in the same ward or not. I think this should be the first
priority to add."

Generating the ward data:

```{r}
(wards <- CRF$ADM |> 
  mutate(across(starts_with("WARD"), as.numeric),
         ward = paste0(SITEID, WARD_1, WARD_2, WARD_3)) |> 
  arrange(SITEID) |> 
  select(USUBJID, ward))
```

An overview of the number of patients per wards:

```{r}
nb_wards <- wards |> 
  group_by(ward) |> 
  tally()

nb_wards |> 
  arrange(desc(n)) |> 
  print(n = Inf)
```


### Enrolled

A function that computes the data for ward occupancy:

```{r}
ward_occupancy <- function(x) {
  f <- function(...) pivot_longer(..., names_to = "change", values_to = "date")
  bind_rows(f(select(x, -DISCHARGE), ADMISSION),
            f(select(x, -ADMISSION), DISCHARGE)) |> 
    arrange(date) |> 
    mutate(across(change, ~ setNames(c(1, -1), c("ADMISSION", "DISCHARGE"))[.x])) |> 
    group_by(date) |> 
    summarise(change = sum(change)) |> 
    ungroup() |> 
    mutate(occupancy = cumsum(change)) |> 
    select(-change)
}
```

A function that plots a ward occupancy:

```{r}
plot_occ <- function(x, y = NULL, ...) {
  x |> 
    first() |> 
    mutate(occupancy = 0) |> 
    bind_rows(x) |> 
    with({
      plot(date, occupancy, type = "n", ...)
      polygon(c(head(date, 2), rep(tail(date, -2), each = 2)),
              c(first(occupancy),
                rep(tail(head(occupancy, -1), -1), each = 2),
                last(occupancy)), col = "grey")
      })
  if (! is.null(y)) abline(v = y, col = "red")
}
```

where `x` is an output from `ward_occupancy()` and `y` is the date of the last
admission of the ward. Putting the ward and dates data together, using
`discharge_dates` for patients who did not provide any sample at discharge (for the
latter, the time is set to noon and, for those who have admission and discharge the
same day with admission in the afternoon, discharge time is then set to one hour after
admission):

```{r}
(ward_dates <- wards |>
  left_join(dates, "USUBJID") |> 
  left_join(discharge_dates, "USUBJID") |> 
  mutate(across(DISCHARGE, ~ if_else(is.na(.x), `Discharge date`, .x)),
         across(DISCHARGE, ~ if_else(as_date(DISCHARGE) == as_date(ADMISSION) &
                                       DISCHARGE < ADMISSION,
                                     ADMISSION + hours(1), DISCHARGE))) |>
  select(- `Discharge date`))
```

Verifying that `DISCHARGE` is after `ADMISSION`:

```{r}
ward_dates |> 
  na.exclude() |> 
  filter(DISCHARGE < ADMISSION)
```

Computing the dates of last admissions for each ward:

```{r}
last_admissions <- ward_dates |> 
  select(-DISCHARGE) |> 
  na.exclude() |> 
  group_by(ward) |> 
  group_modify(~ .x |>
                   arrange(ADMISSION) |>
                   last()) |> 
  ungroup() |> 
  pull(ADMISSION)
```

Computing and plotting the ward occupancies:

```{r fig.height = 10.38, fig.width  = 8.3}
#| label: fig-occupancies
#| fig-cap: "Number of patients enrolled as a function of time for each ward. The red vertical line indicates the last enrollment."
opar <- par(mfrow = c(8, 4))
ward_dates |> 
  group_by(ward) |> 
  group_map(~ ward_occupancy(.x), .keep = TRUE) |> 
  walk2(last_admissions, plot_occ, ann = FALSE)
par(opar)
```


### Durations

The distribution of the durations of stay in the wards:

```{r}
#| label: fig-durations_distribution
#| fig-cap: "The distribution of the time spent in the ward."
ward_dates |> 
  mutate(duration = as.numeric(DISCHARGE - ADMISSION) / mpd) |> 
  pull(duration) |> 
  hist2(xlab = "duration of stay (days)", ylab = "number of patients")
```

Let's see whether there any trend on the duration of stay across wards:

```{r}
#| label: fig-durations_nb_patients
#| fig-cap: "The duration of stay as a function of the number of patients enrolled
#| across the wards."
the_data <- ward_dates |> 
  mutate(duration = as.numeric(DISCHARGE - ADMISSION) / mpd) |> 
  left_join(nb_wards, "ward") |> 
  select(n, duration)

the_model <- gam(duration ~ s(n), Gamma, the_data, method = "REML") |> 
  fitted_values(tibble(n = seq(min(the_data$n), max(the_data$n), le = 512)))
  
with(the_data, plot(jitter(n, 5), duration, col = adjustcolor("black", .1), pch = 19,
                    xlab = "number of patients enrolled",
                    ylab = "duration of stay (days)"))

color_model <- "steelblue"
with(the_model, {
  polygon2(n, .lower_ci, .upper_ci, col = adjustcolor(color_model, .3))
  lines(n, .fitted, col = color_model)
})
```


## MALDI-TOF data {#sec-malditof_data}

Reading the MALDI-TOF data:

```{r}
(MALDITOF <- path2data |>
  paste0(MALDITOF_file) |>
  read_excel() |> 
  select(USUBJID, SampleSchedule, Identification_MALDITOF) |> 
  unique())
```

The list of positive samples:

```{r}
(MALDITOF_samples <- MALDITOF |> 
  select(- Identification_MALDITOF) |> 
  unique())
```

The number of positive samples at admission is:

```{r}
(nb_positive_samples_admission <- MALDITOF_samples |> 
  filter(SampleSchedule == "ADMISSION") |> 
  nrow())
```

The number of positive samples at admission is:

```{r}
(nb_positive_samples_discharge <- MALDITOF_samples |> 
  filter(SampleSchedule == "DISCHARGE") |> 
  nrow())
```

The number of positive samples is:

```{r}
(nb_positive_samples <- nb_positive_samples_admission + nb_positive_samples_discharge)
```

Which represents `{r} round(100 * nb_positive_samples / nb_samples, 2)` % of
samples. The distribution of bacteria across the samples:

```{r}
prevalences <- function(x, nb_positive_samples, nb_samples) {
  x |> 
    group_by(Identification_MALDITOF) |> 
    tally() |> 
    mutate(`% +ve smpls` = round(100 * n / nb_positive_samples, 1),
           `% all smpls` = round(100 * n / nb_samples, 1)) |> 
    arrange(desc(n))
}
```

Prevalences across all samples:

```{r}
(prevalences_all <- prevalences(MALDITOF, nb_positive_samples, nb_samples))
```

The list of all the bacteria in the MALDITOF results:

```{r}
(bugs <- prevalences_all |> 
  filter(Identification_MALDITOF != "unidentified") |> 
  pull(Identification_MALDITOF) |> 
  sort())
```

Prevalences at admission:

```{r}
(prevalences_admission <- MALDITOF |> 
  filter(SampleSchedule == "ADMISSION") |> 
  prevalences(nb_positive_samples_admission, nb_samples_admission))
```

Prevalences at discharge:

```{r}
(prevalences_discharge <- MALDITOF |> 
  filter(SampleSchedule == "DISCHARGE") |> 
  prevalences(nb_positive_samples_discharge, nb_samples_discharge))
```

Let's compare the prevalences at admission and discharge:

```{r}
prev_adm_disch <- prevalences_all |> 
  select(Identification_MALDITOF) |> 
  left_join(prevalences_admission, "Identification_MALDITOF") |> 
  left_join(prevalences_discharge, "Identification_MALDITOF",
            suffix = c(" (A)", " (D)")) |> 
  mutate(across(everything(), ~ replace_na(.x, 0)))
```

The number of positive samples:

```{r}
prev_adm_disch |> 
  select(Identification_MALDITOF, starts_with("n"))
```

Their proportion among positive samples:

```{r}
prev_adm_disch |> 
  select(Identification_MALDITOF, starts_with("% +"))
```

Their proportions among all samples:

```{r}
prev_adm_disch |> 
  select(Identification_MALDITOF, starts_with("% a"))
```

The list of bacteria absent at admission and present at discharge:

```{r}
prev_adm_disch |> 
  select(Identification_MALDITOF, starts_with("n")) |> 
  filter(`n (A)` == 0)
```

The list of bacteria present at admission and absent at discharge:

```{r}
prev_adm_disch |> 
  select(Identification_MALDITOF, starts_with("n")) |> 
  filter(`n (D)` == 0)
```

Let's now look at changes in colonization status between admission and discharge. The
following function prepares the data for an alluvial plot:

```{r}
make_alluvial_data <- function(x) {
  positive_samples <- x |> 
    mutate(state = 2) |> # the exact value here does not matter
    pivot_wider(names_from = SampleSchedule, values_from = state) |> 
    mutate(across(-USUBJID, ~ ! is.na(.x)))

  dates |> 
    filter(! is.na(DISCHARGE)) |> 
    select(USUBJID) |> 
    left_join(positive_samples, "USUBJID") |> 
    mutate(across(-USUBJID, ~ replace_na(.x, FALSE)),
           across(-USUBJID, ~ c("cleared", "colonized")[as.numeric(.x) + 1])) |> 
    group_by(ADMISSION, DISCHARGE) |> 
    tally() |> 
    ungroup()
}
```

The following function is a wrapper around the above function and the the `alluvial3()`
function that computes the table of changes and plot the alluvial plot for a given set
of bacteria to consider:

```{r}
plot_changes <- function(bacteria = "all") {
  if (bacteria == "all") {
    the_data <- MALDITOF_samples
  } else {
    the_data <- MALDITOF |> 
           filter(Identification_MALDITOF %in% bacteria) |> 
           select(- Identification_MALDITOF)
  }
  the_data |>
    make_alluvial_data() |> 
    alluvial3(col = "grey", alpha = .8, border = NA)
}
```

Let's use this function to look at some example:

```{r}
#| label: fig-alluvial_all
#| fig-cap: "The change of colonization status by any CRE between admission and discharge."
plot_changes()
```

```{r}
#| label: fig-alluvial_Ecoli
#| fig-cap: "The change of colonization status by *E. coli* between admission and discharge."
plot_changes("Escherichia coli")
```

```{r}
#| label: fig-alluvial_Kp
#| fig-cap: "The change of colonization status by *K. pneumoniae* between admission and discharge."
plot_changes("Klebsiella pneumoniae")
```


## CRE exposure

### All CRE {#sec-proportion_CRE}

The number of enrolled patient with CRE at admission as a function of time for each
ward (takes **1.5"**):

```{r fig.height = 10.38, fig.width  = 8.3}
#| label: fig-CREoccupancies
#| fig-cap: "Number of enrolled patients with CRE at admission as a function of time for each ward."
opar <- par(mfrow = c(8, 4))

CRE_admission <- MALDITOF_samples |> 
  filter(SampleSchedule == "ADMISSION") |> 
  pull(USUBJID)

ward_dates |> 
  filter(USUBJID %in% CRE_admission) |> 
  group_by(ward) |> 
  group_map(~ ward_occupancy(.x), .keep = TRUE) |> 
  walk(plot_occ, ann = FALSE)

par(opar)
```

A function that plots the prevalence estimate `estimate` and lower and upper bonds
`lower` and `upper` of the confidence interval from a data frame of a ward:

```{r}
plot_prevalence <- function(x) {
  with(x, plot(x_transform(date), y_transform(estimate),
               type = "n", ann = FALSE, ylim = 0:1))
  x |> 
    duplicate_NA_rows() |> 
    remove_NAs(estimate) |> 
    map(~ with(.x, polygon2(x_transform(date), y_transform(lower), y_transform(upper),
                            col = "grey")))
  with(x, lines(x_transform(date), y_transform(estimate)))
}
```

Computing the proportions of CRE positives as a function of time for each ward (takes
**1.5"**):

```{r}
numerator_df <- ward_dates |> 
  filter(USUBJID %in% CRE_admission) |> 
  group_by(ward) |> 
  group_modify(~ ward_occupancy(.x)) |> 
  rename(numerator = occupancy)

proportion_CRE <- ward_dates |> 
  group_by(ward) |> 
  group_modify(~ ward_occupancy(.x)) |> 
  ungroup() |> 
  rename(denominator = occupancy) |>
  left_join(numerator_df, c("ward", "date")) |> 
  fill(numerator) |> 
  mutate(across(numerator, ~ replace_na(.x, 0)),
         Clopper_Pearson = map2(numerator, denominator, binom_test)) |> 
  unnest_wider(Clopper_Pearson)
```

Proportion of enrolled patients that are CRE positive at admission as a function of
time for each ward (takes **1.5"**):

```{r fig.height = 10.38, fig.width  = 8.3}
#| label: fig-CREprevalences
#| fig-cap: "Proportion of enrolled patients that are CRE positive at admission as a function of time for each ward."

opar <- par(mfrow = c(8, 4))
proportion_CRE |> 
  group_by(ward) |> 
  group_walk(~ plot_prevalence(.x))
par(opar)
```


### *K. pneumoniae*

Here we have the same plots as for the previous section but for *K. pneumoniae* only.
First the number of enrolled patient with CRE *K. pneumoniae* at admission as a
function of time for each ward (takes **1"**):

```{r fig.height = 10.38, fig.width  = 8.3}
#| label: fig-Kp_occupancies
#| fig-cap: "Number of enrolled patients with CRE *K pneumonia* at admission as a function of time for each ward."
opar <- par(mfrow = c(8, 4))

Kp_admission <- MALDITOF |> 
  filter(SampleSchedule == "ADMISSION",
         Identification_MALDITOF == "Klebsiella pneumoniae") |> 
  pull(USUBJID)

ward_dates |> 
  filter(USUBJID %in% Kp_admission) |> 
  group_by(ward) |> 
  group_map(~ ward_occupancy(.x), .keep = TRUE) |> 
  walk(plot_occ, ann = FALSE)

par(opar)
```

Proportion of enrolled patients that are CRE *K. pneumoniae* positive at admission as a
function of time for each ward (takes **1.5"**):

```{r fig.height = 10.38, fig.width  = 8.3}
#| label: fig-Kp_prevalences
#| fig-cap: "Proportion of enrolled patients that are CRE *K. pneumoniae* positive at admission as a function of time for each ward."
numerator_df <- ward_dates |> 
  filter(USUBJID %in% Kp_admission) |> 
  group_by(ward) |> 
  group_modify(~ ward_occupancy(.x)) |> 
  rename(numerator = occupancy)

opar <- par(mfrow = c(8, 4))

ward_dates |> 
  group_by(ward) |> 
  group_modify(~ ward_occupancy(.x)) |> 
  ungroup() |> 
  rename(denominator = occupancy) |>
  left_join(numerator_df, c("ward", "date")) |> 
  fill(numerator) |> 
  mutate(across(numerator, ~ replace_na(.x, 0)),
         Clopper_Pearson = map2(numerator, denominator, binom_test)) |> 
  unnest_wider(Clopper_Pearson) |> 
  group_by(ward) |> 
  group_walk(~ plot_prevalence(.x))

par(opar)
```


## Data preparation

### Minimum data

A function that generates the presence/absence data (coded as 1/2 here) from the output
`x` of the MALDITOF where `id` is the column of `x` that contains the patient ID,
`time_point` is the column of `x` that contains the time point of the sample (e.g.
`ADMISSION` or `DISCHARGE`), `identification` is the column of `x` that contains the
bacteria identified by the MALDITOF and `bacteria` is a vector of characters that
contains the names of the bacteria that we want to test the presence of.

```{r}
presence_abscence <- function(x, id, time_point, identification, bacteria) {
  x |> 
    group_by({{ id }}, {{ time_point }}) |> 
    group_modify(~ col2listcol(.x, {{ identification }})) |> 
    ungroup() |> 
    mutate(state = map_lgl({{ identification }}, ~ any(bacteria %in% .x)) + 1) |>
    select(- {{ identification }}) |> 
    arrange({{ id }}, {{ time_point }})
}
```

The following function adds the samples that were tested negative to the output `x` of
`presence_abscence()` where `y` is the samples dates as generated in
@sec-samples_dates.

```{r}
add_negatives <- function(x, y, id, time_point) {
  tp <- as_name(enquo(time_point))
  y |> 
    pivot_longer(- {{ id }}, names_to = tp) |> 
    left_join(x, c(as_name(enquo(id)), tp)) |> 
    mutate(across(state, ~ replace_na(., 1))) |> 
    na.exclude() # remove the absence of samples
}
```

A function that selects patients from `x` who have samples from at least 2 time points:

```{r}
select2time_points <- function(x, id) {
  id_with_2obs <- x |> 
    pull({{ id }}) |> 
    table() |> 
    is_greater_than(1) |> 
    which() |> 
    names()
  
  filter(x, {{ id }} %in% id_with_2obs)
}
```

where `id` is the column of `x` that contains the patients IDs. A function that
combines state and time data:

```{r}
state_time <- function(state, time, id, admission, discharge, time_point) {
  time |> 
    mutate("{{discharge}}" := as.numeric({{ discharge }} - {{ admission }}) / mpd,
           "{{admission}}" := 0) |> 
    pivot_longer(- {{ id }},
                 names_to = as_name(enquo(time_point)), values_to = "days") |>
    left_join(x = {{ state }}, y = _,
              c(as_name(enquo(id)), as_name(enquo(time_point))))
}
```

The following function puts the 4 above functions together:

```{r}
msm_data <- function(x, y, id, time_point, identification, bacteria,
                     admission, discharge) {
  x |>
    presence_abscence({{ id }}, {{ time_point }}, {{ identification }}, bacteria) |> 
    add_negatives(y, {{ id }}, {{ time_point }}) |> 
    select2time_points({{ id }}) |> 
    state_time(y, {{ id }}, {{ admission }}, {{ discharge }}, {{ time_point }}) |> 
    select({{ id }}, state, days)
}
```

where

* `x` is the MALDITOF data as read in section @sec-malditof_data
* `y` is the dates of samples collections as generated from the CRF in section
@sec-samples_dates
* `id` is the unquoted name of the patient ID variable that should be the same in `x`
and `y`
* `time_point` is the unquoted name of the variable of `x` that contains the time
point information (for example `ADMISSION` and `DISCHARGE`)
* `identification` is the unquoted name of the variable of `x` that contains the name
of the identified bacteria
* `bacteria` is a vector of quoted names of bacteria we want to generate the data for
* `admission` is the unquoted name of the variable of `y` that contains the dates of
admissions
* `discharge` is the unquoted name of the variable of `y` that contains the dates of
discharge

The output of this function is a data frame with 3 columns:

* the `id` patient ID
* the `state` variable, with `1` and `2` for not "not infected" and "infected"
respectively
* the `days` columns where zeros refers to admissions and non-zero values are the
times of discharge in days counting from admission

A tuning of `msm_data()`:

```{r}
msm_data2 <- function(bacteria) msm_data(MALDITOF, dates, USUBJID, SampleSchedule,
                                         Identification_MALDITOF, bacteria, ADMISSION,
                                         DISCHARGE)
```

### Covariates

The following function adds to the output `x` of the `msm_data()` function the
covariate `otherCRE` that tells whether at admission the patient had a CRE other than
the set of `bacteria`:

```{r}
add_other_CRE_at_admission <- function(x, bacteria) {
  MALDITOF |> 
    filter(SampleSchedule == "ADMISSION",
           ! Identification_MALDITOF %in% bacteria) |> 
    mutate(otherCRE = TRUE) |> 
    select(USUBJID, otherCRE) |> 
    unique() |> 
    left_join(x = x, y = _, "USUBJID") |> 
    mutate(across(otherCRE, ~ replace_na(.x, FALSE)))
}
```

This function relies on the `MALDITOF` data frame generated in section
@sec-malditof_data. The following function adds to the output `x` of the `msm_data()`
function the `ward` ID covariate:

```{r}
add_ward <- function(x) left_join(x, wards, "USUBJID")
```

This function relies on the `wards` data frame generated in the section @sec-wards. The
following function adds to the output `x` of the `add_ward()` function the covariates
`estimate`, `lower` and `upper` that are the temporal means of the proportions of
enrolled patient that are CRE positive in the ward for the duration of the study:

```{r}
add_CRE_prevalence_in_ward <- function(x) {
  ward_means <- function(y) {
    total_duration <- time_diff(range(y$date))
    y |> 
      mutate(weight = time_diff(c(date, NA)) / total_duration) |> 
      summarise(across(c(estimate, lower, upper),
                       ~ sum(replace_na(.x, 0) * weight, na.rm = TRUE)))
  }
  proportion_CRE |> 
    group_by(ward) |> 
    group_modify(~ ward_means(.x)) |> 
    ungroup() |> 
    left_join(x = x, y = _, "ward")
}
```

This function relies on the `proportion_CRE` data frame generated in the section
@sec-proportion_CRE.

## *K. pneumoniae*

### Preparing the data

Generating the presence/absence of *K. pneumoniae* (takes **2.5"**):

```{r eval = FALSE}
K_pneumoniae_raw <- presence_abscence(MALDITOF, USUBJID, SampleSchedule,
                                      Identification_MALDITOF, "Klebsiella pneumoniae")
```

```{r include = FALSE, warning = FALSE}
if (file_exists("K_pneumoniae_raw.rds")) {
  K_pneumoniae_raw <- readRDS2("K_pneumoniae_raw.rds")
} else {
  K_pneumoniae_raw <- presence_abscence(MALDITOF, USUBJID, SampleSchedule,
                                        Identification_MALDITOF,
                                        "Klebsiella pneumoniae")
  saveRDS2(K_pneumoniae_raw, "K_pneumoniae_raw.rds")
}
```

Which gives:

```{r}
K_pneumoniae_raw
```

Where `1` is absence and `2` is presence. Adding the samples with negative culture:

```{r}
(K_pneumoniae_raw_a <- add_negatives(K_pneumoniae_raw, dates, USUBJID, SampleSchedule))
```

Selecting the patients that have samples from at least 2 time points:

```{r}
(K_pneumoniae <- select2time_points(K_pneumoniae_raw_a, USUBJID))
```

Making the dataset for the multistate modelling:

```{r}
(Kp_msm <- state_time(K_pneumoniae, dates, USUBJID,
                      ADMISSION, DISCHARGE, SampleSchedule))
```

Alternatively, we can do all at once with this function (takes **2.5"**):

```{r eval = FALSE}
Kp_msm <- msm_data(MALDITOF, dates, USUBJID, SampleSchedule, Identification_MALDITOF,
                   "Klebsiella pneumoniae", ADMISSION, DISCHARGE)
```

```{r include = FALSE, warning = FALSE}
if (file_exists("Kp_msm.rds")) {
  Kp_msm <- readRDS2("Kp_msm.rds")
} else {
  Kp_msm <- msm_data(MALDITOF, dates, USUBJID, SampleSchedule, Identification_MALDITOF,
                     "Klebsiella pneumoniae", ADMISSION, DISCHARGE)
  saveRDS2(Kp_msm, "Kp_msm.rds")
}
```

which gives:

```{r}
Kp_msm
```

Or, even simpler here (takes **2.5"**):

```{r eval = FALSE}
Kp_msm <- msm_data2("Klebsiella pneumoniae")
```

Adding covariates:

```{r}
(Kp_msm_cov <- Kp_msm |> 
   add_other_CRE_at_admission("Klebsiella pneumoniae") |> 
   add_ward() |> 
   add_CRE_prevalence_in_ward())
```


### Multi-state modelling

#### Basic operations

Defining the structure of the $Q$ matrix:

```{r}
Q <- rbind(c(0, 1),
           c(1, 0))
```

Initial values of the $Q$ matrix:

```{r}
(Q_crude <- crudeinits.msm(state ~ days, USUBJID, Q, Kp_msm))
```

Fitting a simple model without any covariate:

```{r}
(Kp_msm_fit <- msm(state ~ days, USUBJID, Kp_msm, Q))
```

Or we call simply do:

```{r}
(Kp_msm_fit <- bsm(state ~ days, USUBJID, Kp_msm))
```

Estimated transition intensity $Q$ matrix:

```{r}
qmatrix.msm(Kp_msm_fit)
```

Estimated transition probability $P$ matrix per day:

```{r}
pmatrix.msm(Kp_msm_fit)
```

Estimated mean sojourn times in each transient state:

```{r}
sojourn.msm(Kp_msm_fit)
```

Log-likelihood of the model:

```{r}
logLik(Kp_msm_fit)
```


#### Bootstrapped CIs

Bootstrapping $Q$ estimates (1000 samples, takes **42" in parallel** on 11 cores):

```{r eval = FALSE}
q_list <- boot.msm(Kp_msm_fit, function(x) qmatrix.msm(x)$estimates, 1000,
                   cores = nb_cores)
```

```{r include = FALSE, warning = FALSE}
if (file_exists("q_list.rds")) {
  q_list <- readRDS2("q_list.rds")
} else {
  q_list <- boot.msm(Kp_msm_fit, function(x) qmatrix.msm(x)$estimates, 1000, cores = nb_cores)
  saveRDS2(q_list, "q_list.rds")
}
```

Reformating the output into an array of dimension 2, 2, and 1000 (i.e. 2 states and
1000 bootstrap samples):

```{r}
q_array <- array(unlist(q_list), dim = c(2, 2, 1000))
```

Or we can simply do this instead of the above two successive command lines (takes **42"
in parallel** on 11 cores):

```{r eval = FALSE}
q_array <- boot_msm(Kp_msm_fit, qmatrix.msm, 1000, cores = nb_cores)
```

```{r include = FALSE, warning = FALSE}
if (file_exists("q_array.rds")) {
  q_array <- readRDS2("q_array.rds")
} else {
  q_array <- boot_msm(Kp_msm_fit, qmatrix.msm, 1000, cores = nb_cores)
  saveRDS2(q_array, "q_array.rds")
}
```

The bootstrap estimate of the standard deviation:

```{r}
apply(q_array, 1:2, sd)
```

Or, equivalently, in a formatted output:

```{r}
boot_stat(q_array)
```

And with the mean:

```{r}
boot_stat(q_array, mean)
```

Or the median:

```{r}
boot_stat(q_array, median)
```

The bootstrap estimate of the 95% confidence interval:

```{r}
q_array |>
  apply(1:2, function(x) quantile(x, c(.025, .975))) |> 
  aperm(c(1, 3, 2))
```

Or, equivalently, in a formatted output:

```{r}
boot_ci(q_array)
```


#### Covariates

```{r}
(Kp_msm_cov_fit <- bsm(state ~ days, USUBJID, Kp_msm_cov,
                       covariates = list("1-2" = ~ otherCRE)))
```

```{r}
qmatrix.msm(Kp_msm_cov_fit, covariates=list(otherCRE = FALSE))
qmatrix.msm(Kp_msm_cov_fit, covariates=list(otherCRE = TRUE))
```

```{r}
(Kp_msm_cov_fit <- bsm(state ~ days, USUBJID, Kp_msm_cov,
                       covariates = list("1-2" = ~ estimate)))
```


#### Diagnostics

```{r}
#| label: fig-diagnostic
#| fig-cap: "Model diagnostic plot."
plot.prevalence.msm(Kp_msm_fit, mintime = 0, maxtime = 15)
```


## Pipelines

### The pipelines

A first pipeline without any covariate:

```{r}
pipeline1 <- function(bacteria) {
  if (bacteria == "all") bacteria <- bugs
  bacteria |>
    msm_data2() |> 
    bsm(state ~ days, USUBJID, data = _) |> 
    bsm_estimations() |> 
    round(2)
}
```

Looking at the presence of other CRE at adminssion as a covariate:

```{r}
pipeline2 <- function(bacteria) {
  if (bacteria == "all") bacteria <- bugs
  bacteria |>
    msm_data2() |> 
    add_other_CRE_at_admission(bacteria) |> 
    bsm(state ~ days, USUBJID, data = _, covariates = ~ otherCRE) |> 
    HR()
}
```

Pipeline 3:

```{r}
pipeline3 <- function(bacteria) {
  if (bacteria == "all") bacteria <- bugs
  bacteria |>
    msm_data2() |> 
    add_ward() |> 
    add_CRE_prevalence_in_ward() |> 
    bsm(state ~ days, USUBJID, data = _, covariates = ~ estimate) |> 
    HR()
}
```

Pipeline 4:

```{r}
pipeline4 <- function(bacteria) {
  if (bacteria == "all") bacteria <- bugs
  bacteria |>
    msm_data2() |> 
    add_ward() |> 
    add_CRE_prevalence_in_ward() |> 
    bsm(state ~ days, USUBJID, data = _, covariates = ~ lower) |> 
    HR()
}
```

Pipeline 5:

```{r}
pipeline5 <- function(bacteria) {
  if (bacteria == "all") bacteria <- bugs
  bacteria |>
    msm_data2() |> 
    add_ward() |> 
    add_CRE_prevalence_in_ward() |> 
    bsm(state ~ days, USUBJID, data = _, covariates = ~ upper) |> 
    HR()
}
```


### Running pipelines

Let's estimate the colonization and clearance rates for several different sets of
bacteria:

```{r}
bacteria_sets <- c("all", "Escherichia coli", "Klebsiella pneumoniae",
                   "Enterobacter hormaechei")
```

Estimates without any covariates (takes **10"**):

```{r eval = FALSE}
pipeline1_results <- bacteria_sets |>
  set_names() |> 
  map(pipeline1)
```

```{r include = FALSE, warning = FALSE}
if (file_exists("pipeline1_results.rds")) {
  pipeline1_results <- readRDS2("pipeline1_results.rds")
} else {
  pipeline1_results <- bacteria_sets |>
    set_names() |> 
    map(pipeline1)
  saveRDS2(pipeline1_results, "pipeline1_results.rds")
}
```

which gives:

```{r}
pipeline1_results
```

Testing the significativity of the presence of other CRE at admission as a covariate
(takes **10"**):

```{r eval = FALSE}
pipeline2_results <- bacteria_sets |>
  set_names() |> 
  map(pipeline2)
```

```{r include = FALSE, warning = FALSE}
if (file_exists("pipeline2_results.rds")) {
  pipeline2_results <- readRDS2("pipeline2_results.rds")
} else {
  pipeline2_results <- bacteria_sets |>
    set_names() |> 
    map(pipeline2)
  saveRDS2(pipeline2_results, "pipeline2_results.rds")
}
```

which gives:

```{r}
pipeline2_results
```

 (takes **10"**)

```{r eval = FALSE}
pipeline3_results <- bacteria_sets |>
  set_names() |> 
  map(pipeline3)
```

```{r include = FALSE, warning = FALSE}
if (file_exists("pipeline3_results.rds")) {
  pipeline3_results <- readRDS2("pipeline3_results.rds")
} else {
  pipeline3_results <- bacteria_sets |>
    set_names() |> 
    map(pipeline3)
  saveRDS2(pipeline3_results, "pipeline3_results.rds")
}
```

which gives:

```{r}
pipeline3_results
```

 (takes **10"**)

```{r eval = FALSE}
pipeline4_results <- bacteria_sets |>
  set_names() |> 
  map(pipeline4)
```

```{r include = FALSE, warning = FALSE}
if (file_exists("pipeline4_results.rds")) {
  pipeline4_results <- readRDS2("pipeline4_results.rds")
} else {
  pipeline4_results <- bacteria_sets |>
    set_names() |> 
    map(pipeline4)
  saveRDS2(pipeline4_results, "pipeline4_results.rds")
}
```

which gives:

```{r}
pipeline4_results
```

 (takes **10"**)

```{r eval = FALSE}
pipeline5_results <- bacteria_sets |>
  set_names() |> 
  map(pipeline5)
```

```{r include = FALSE, warning = FALSE}
if (file_exists("pipeline5_results.rds")) {
  pipeline5_results <- readRDS2("pipeline5_results.rds")
} else {
  pipeline5_results <- bacteria_sets |>
    set_names() |> 
    map(pipeline5)
  saveRDS2(pipeline5_results, "pipeline5_results.rds")
}
```

which gives:

```{r}
pipeline5_results
```
