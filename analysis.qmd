---
title: "60HN"
number-sections: true
format:
  html:
    toc: true
    toc-depth: 4
editor: source
editor_options: 
  chunk_output_type: console
#bibliography: references.bib
#csl: the-american-naturalist.csl
---

```{r include = FALSE, eval = FALSE}
knitr::purl("malarone.qmd", "tmp.R", documentation = FALSE)
source("tmp.R")
file.remove("tmp.R")

add_nojekyll <- function() {
  file <- ".nojekyll"
  file.create(file)
  gert::git_add(file)
  gert::git_commit("Adding the .nojekyll file")
  gert::git_push()
}
```

```{r include = FALSE}
par2 <- function(...) par(..., mgp = c(1.5, .5, 0), bty = "n")

knitr::knit_hooks$set(
  margin1 = function(before, options, envir) {
    if (before) par2(plt = c(.105, .97, .15, .95)) else NULL
  })

eps <- .8
knitr::opts_chunk$set(margin1    = TRUE,
                      fig.retina = 2,
                      fig.align  = "center",
                      fig.height = eps * 5, # default is 5
                      fig.width  = eps * 7) # default is 7
```


## Constants

The folder that contains the data files:

```{r}
path2data <- paste0("/Users/MarcChoisy/Library/CloudStorage/",
                    "OneDrive-OxfordUniversityClinicalResearchUnit/",
                    "GitHub/choisy/60HN/")
```

```{r include = FALSE}
path2cache <- paste0(path2data, "cache/")
if (! dir.exists(path2cache)) dir.create(path2cache)
make_path <- function(x) paste0(path2cache, x)
file_exists <- function(x) file.exists(make_path(x))
readRDS2 <- function(x) readRDS(make_path(x))
saveRDS2 <- function(object, file) saveRDS(object, make_path(file))
```

The name of the CRF data file:

```{r}
CRF_file <- "29-10-2025-_60HN_PATIENT_P1_Data.xlsx"
```

The name of the MALDI-TOF data file:

```{r}
MALDITOF_file <- paste0("60HN_LAB_ID_20251014_merged_Blue and",
                        " pink_confirmed by Maldi-TOF.xlsx")
```


## Packages

Required packages:

```{r}
required <- c("readxl", "purrr", "dplyr", "lubridate", "magrittr", "tidyr", "msm")
```

Installing those that are not installed yet:

```{r}
to_install <- required[! required %in% installed.packages()[,"Package"]]
if (length(to_install)) install.packages(to_install)
```

Loading some packages for interactive use:

```{r warning = FALSE, message = FALSE}
library(readxl)
library(purrr)
library(dplyr)
library(lubridate)
library(magrittr)
library(tidyr)
library(msm)
```


## Functions

A function that converts a column `col` of a data frame `x` into a list-column
(assuming that all the other columns have the same values across rows):

```{r}
col2listcol <- function(x, col) {
  x |> 
    select(- {{ col }}) |> 
    head(1) |> 
    bind_cols(tibble("{{col}}" := list(pull(x, {{ col }}))))
}
```


## CRF data

Reading the data:

```{r eval = FALSE}
file <- paste0(path2data, CRF_file)

sheets <- file |>
  excel_sheets() |> 
  head(-1)

CRF <- sheets |> 
  map(read_excel, path = file) |> 
  setNames(sheets) |> 
  map(~ .x |>  # de-duplication of records
        group_by(USUBJID) |> 
        group_modify(~ .x |>
                       arrange(desc(entry)) |> 
                       first()) |> 
        ungroup())
```

```{r include = FALSE, warning = FALSE}
if (file_exists("CRF.rds")) {
  CRF <- readRDS2("CRF.rds")
} else {
  file <- paste0(path2data, CRF_file)
  sheets <- file |>
    excel_sheets() |> 
    head(-1)
  
  CRF <- sheets |> 
    map(read_excel, path = file) |> 
    setNames(sheets) |> 
    map(~ .x |>  # de-duplication of records
          group_by(USUBJID) |> 
          group_modify(~ .x |>
                         arrange(desc(entry)) |> 
                         first()) |> 
          ungroup())

  saveRDS2(CRF, "CRF.rds")
}
```

The dates of samples collection at admission and discharge:

```{r}
(dates <- CRF$SCR |> 
  select(USUBJID, SPEC_DATE_ADMISSION, SPEC_TIME_ADMISSION,
                  SPEC_DATE_DISCHARGE, SPEC_TIME_DISCHARGE) |> 
  na.exclude() |> 
  mutate(ADMISSION = as_datetime(paste(SPEC_DATE_ADMISSION, SPEC_TIME_ADMISSION)),
         DISCHARGE = as_datetime(paste(SPEC_DATE_DISCHARGE, SPEC_TIME_DISCHARGE))) |> 
  select(- SPEC_DATE_ADMISSION, - SPEC_TIME_ADMISSION,
         - SPEC_DATE_DISCHARGE, - SPEC_TIME_DISCHARGE))
```


## MALDI-TOF data

Reading the MALDI-TOF data:

```{r}
(MALDITOF <- path2data |>
  paste0(MALDITOF_file) |>
  read_excel() |> 
  select(USUBJID, SampleSchedule, Identification_MALDITOF))
```


## *K. pneumoniae*

A function that generates the presence/absence data from the output `x` of the MALDITOF
where `id` is the column of `x` that contains the patient ID, `time_point` is the
column of `x` that contains the time point of the sample (e.g. `ADMISSION` or
`DISCHARGE`), `identification` is the column of `x` that contains the bacteria
identified by the MALDITOF and `bacteria` is a vector of characters that contains the
names of the bacteria that we want to test the presence of.

```{r}
presence_abscence <- function(x, id, time_point, identification, bacteria) {
  x |> 
    group_by({{ id }}, {{ time_point }}) |> 
    group_modify(~ col2listcol(.x, {{ identification }})) |> 
    ungroup() |> 
    mutate(state = map_lgl({{ identification }}, ~ any(bacteria %in% .x)) + 1) |> 
    select(- {{ identification }}) |> 
    arrange({{ id }}, {{ time_point }})
}
```


### Preparing the data

Generating the presence/absence of *K. pneumoniae*:

```{r eval = FALSE}
K_pneumoniae_raw <- presence_abscence(MALDITOF, USUBJID, SampleSchedule,
                                      Identification_MALDITOF, "Klebsiella pneumoniae")
```

```{r include = FALSE, warning = FALSE}
if (file_exists("K_pneumoniae_raw.rds")) {
  K_pneumoniae_raw <- readRDS2("K_pneumoniae_raw.rds")
} else {
  K_pneumoniae_raw <- presence_abscence(MALDITOF, USUBJID, SampleSchedule,
                                        Identification_MALDITOF,
                                        "Klebsiella pneumoniae")
  saveRDS2(K_pneumoniae_raw, "K_pneumoniae_raw.rds")
}
```

Which gives:

```{r}
K_pneumoniae_raw
```

Not all the patients have both `ADMISSION` and `DISCHARGE`:

```{r}
K_pneumoniae_raw |> 
  pull(USUBJID) |> 
  table() |> 
  table()
```

The IDs of the patients who do have both `ADMISSION` and `DISCHARGE`:

```{r}
id_with_2obs <- K_pneumoniae_raw |> 
  pull(USUBJID) |> 
  table() |> 
  is_greater_than(1) |> 
  which() |> 
  names()
```

Selecting the patients who do have both `ADMISSION` and `DISCHARGE`:

```{r}
K_pneumoniae <- filter(K_pneumoniae_raw, USUBJID %in% id_with_2obs)
```

Making the dataset for the multistate modelling:

```{r}
(Kp_msm <- dates |> 
  mutate(DISCHARGE = as.numeric(DISCHARGE - ADMISSION) / (24 * 60),
         ADMISSION = 0) |> 
  pivot_longer(- USUBJID, names_to = "SampleSchedule", values_to = "days") |> 
  left_join(x = K_pneumoniae, y = _, c("USUBJID", "SampleSchedule")) |> 
  mutate(days = map_dbl(days, ~ max(.x, 0))))                  ### THIS SHOULD NOT BE NEEDED ANYMORE
```

### Multi-state modelling

Defining the structure of the $Q$ matrix:

```{r}
Q <- rbind(c(0, 1),
           c(1, 0))
```

Initial values of the $Q$ matrix:

```{r}
(Q_crude <- crudeinits.msm(state ~ days, USUBJID, Q, Kp_msm))
```

Fitting a simple model without any covariate:

```{r}
(Kp_msm_fit <- msm(state ~ days, USUBJID, Kp_msm, Q))
```

Estimated transition intensity $Q$ matrix:

```{r}
qmatrix.msm(Kp_msm_fit)
```

Estimated transition probability $P$ matrix per day:

```{r}
pmatrix.msm(Kp_msm_fit)
```

Estimated mean sojourn times in each transient state:

```{r}
sojourn.msm(Kp_msm_fit)
```

Log-likelihood of the model:

```{r}
logLik(Kp_msm_fit)
```


#### Bootstrapped CIs

Bootstrapping $Q$ estimates (1000 saamples):

```{r eval = FALSE}
q_list <- boot.msm(Kp_msm_fit, function(x) qmatrix.msm(x)$estimates, 1000)
```

```{r include = FALSE, warning = FALSE}
if (file_exists("q_list.rds")) {
  q_list <- readRDS2("q_list.rds")
} else {
q_list <- boot.msm(Kp_msm_fit, function(x) qmatrix.msm(x)$estimates)
saveRDS2(q_list, "q_list.rds")
}
```

Reformating the output into an array of dimension 2, 2, and 1000 (i.e. 2 states and
1000 bootstrap samples):

```{r}
q_array <- array(unlist(q_list), dim = c(2, 2, 1000))
```

The bootstrap estimate of the standard deviation:

```{r}
apply(q_array, 1:2, sd)
```

The bootstrap estimate of the 95% confidence interval:

```{r}
apply(q_array, 1:2, function(x) quantile(x, c(.025, .975)))
```

