---
title: "60HN"
number-sections: true
format:
  html:
    toc: true
    toc-depth: 4
editor: source
editor_options: 
  chunk_output_type: console
#bibliography: references.bib
#csl: the-american-naturalist.csl
---

```{r include = FALSE, eval = FALSE}
knitr::purl("malarone.qmd", "tmp.R", documentation = FALSE)
source("tmp.R")
file.remove("tmp.R")

add_nojekyll <- function() {
  file <- ".nojekyll"
  file.create(file)
  gert::git_add(file)
  gert::git_commit("Adding the .nojekyll file")
  gert::git_push()
}
```

```{r include = FALSE}
par2 <- function(...) par(..., mgp = c(1.5, .5, 0), bty = "n")

knitr::knit_hooks$set(
  margin1 = function(before, options, envir) {
    if (before) par2(plt = c(.105, .97, .15, .95)) else NULL
  })

eps <- .8
knitr::opts_chunk$set(margin1    = TRUE,
                      fig.retina = 2,
                      fig.align  = "center",
                      fig.height = eps * 5, # default is 5
                      fig.width  = eps * 7) # default is 7
```


## Constants

The folder that contains the data files:

```{r}
path2data <- paste0("/Users/", Sys.getenv("USER"), "/Library/CloudStorage/",
                    "OneDrive-OxfordUniversityClinicalResearchUnit/",
                    "GitHub/choisy/60HN/")
```

```{r include = FALSE}
path2cache <- paste0(path2data, "cache/")
if (! dir.exists(path2cache)) dir.create(path2cache)
make_path <- function(x) paste0(path2cache, x)
file_exists <- function(x) file.exists(make_path(x))
readRDS2 <- function(x) readRDS(make_path(x))
saveRDS2 <- function(object, file) saveRDS(object, make_path(file))
```

The name of the CRF data file:

```{r}
CRF_file <- "29-10-2025-_60HN_PATIENT_P1_Data_corrected_by_Marc.xlsx"
```

<!-- 
discharge sample collection date corrected for 010-1-1-63, 160-1-1-63, 160-1-1-87 and 008-1-1-53
-->

The name of the MALDI-TOF data file:

```{r}
MALDITOF_file <- paste0("60HN_LAB_ID_20251014_merged_Blue and",
                        " pink_confirmed by Maldi-TOF.xlsx")
```


## Packages

Required packages:

```{r}
required <- c("readxl", "purrr", "dplyr", "lubridate", "magrittr", "tidyr", "msm",
              "rlang")
```

Installing those that are not installed yet:

```{r}
to_install <- required[! required %in% installed.packages()[,"Package"]]
if (length(to_install)) install.packages(to_install)
```

Loading some packages for interactive use:

```{r warning = FALSE, message = FALSE}
library(readxl)
library(purrr)
library(dplyr)
library(lubridate)
library(magrittr)
library(tidyr)
library(msm)
library(rlang)
```


## General functions

A function that converts a column `col` of a data frame `x` into a list-column
(assuming that all the other columns have the same values across rows):

```{r}
col2listcol <- function(x, col) {
  x |> 
    select(- {{ col }}) |> 
    head(1) |> 
    bind_cols(tibble("{{col}}" := list(pull(x, {{ col }}))))
}
```

A tuning of the `msm()` function for a bi-state bi-directional case:

```{r}
bsm <- function(formula, subject, data, ...) {
  output <- do.call(msm::msm, c(list(formula = formula,
                                     subject = substitute(subject),
                                     data    = data,
                                     qmatrix = matrix(c(0:1, 1:0), 2)), list(...)))
  output$call <- match.call()
  output
}
```

A function that bootstraps estimates of the fitted multistate model `msm_fit` where `f`
is the function that generates the estimates and `N` is the number of bootstrap
repetitions:

```{r}
boot_msm <- function(msm_fit, f = qmatrix.msm, N = 1000) {
  msm_fit |>
    boot.msm(function(x) f(x)$estimates, N) |> 
    unlist() |> 
    array(dim = c(dim(msm_fit$Qmatrices$baseline), N))
}
```

A function that generate statistic `f` estimates from bootstrap samples `boot_stat`
outputed by `boot_msm()`:

```{r}
boot_stat <- function(boots_samples, f = sd) {
  output <- apply(boots_samples, 1:2, f)
  mat_names <- paste("State", 1:nrow(output))
  colnames(output) <-  mat_names
  rownames(output) <-  mat_names
  output
}
```


## CRF data

Reading the data:

```{r eval = FALSE}
file <- paste0(path2data, CRF_file)

sheets <- file |>
  excel_sheets() |> 
  head(-1)

CRF <- sheets |> 
  map(read_excel, path = file) |> 
  setNames(sheets) |> 
  map(~ .x |>  # de-duplication of records
        group_by(USUBJID) |> 
        group_modify(~ .x |>
                       arrange(desc(entry)) |> 
                       first()) |> 
        ungroup())
```

```{r include = FALSE, warning = FALSE}
if (file_exists("CRF.rds")) {
  CRF <- readRDS2("CRF.rds")
} else {
  file <- paste0(path2data, CRF_file)
  sheets <- file |>
    excel_sheets() |> 
    head(-1)
  
  CRF <- sheets |> 
    map(read_excel, path = file) |> 
    setNames(sheets) |> 
    map(~ .x |>  # de-duplication of records
          group_by(USUBJID) |> 
          group_modify(~ .x |>
                         arrange(desc(entry)) |> 
                         first()) |> 
          ungroup())

  saveRDS2(CRF, "CRF.rds")
}
```

The dates of samples collection at admission and discharge:

```{r}
(dates <- CRF$SCR |> 
  select(USUBJID, SPEC_DATE_ADMISSION, SPEC_TIME_ADMISSION,
                  SPEC_DATE_DISCHARGE, SPEC_TIME_DISCHARGE) |> 
  na.exclude() |> 
  mutate(ADMISSION = as_datetime(paste(SPEC_DATE_ADMISSION, SPEC_TIME_ADMISSION)),
         DISCHARGE = as_datetime(paste(SPEC_DATE_DISCHARGE, SPEC_TIME_DISCHARGE))) |> 
  select(- SPEC_DATE_ADMISSION, - SPEC_TIME_ADMISSION,
         - SPEC_DATE_DISCHARGE, - SPEC_TIME_DISCHARGE))
```


## MALDI-TOF data

Reading the MALDI-TOF data:

```{r}
(MALDITOF <- path2data |>
  paste0(MALDITOF_file) |>
  read_excel() |> 
  select(USUBJID, SampleSchedule, Identification_MALDITOF))
```


## Specific functions

A function that generates the presence/absence data from the output `x` of the MALDITOF
where `id` is the column of `x` that contains the patient ID, `time_point` is the
column of `x` that contains the time point of the sample (e.g. `ADMISSION` or
`DISCHARGE`), `identification` is the column of `x` that contains the bacteria
identified by the MALDITOF and `bacteria` is a vector of characters that contains the
names of the bacteria that we want to test the presence of.

```{r}
presence_abscence <- function(x, id, time_point, identification, bacteria) {
  x |> 
    group_by({{ id }}, {{ time_point }}) |> 
    group_modify(~ col2listcol(.x, {{ identification }})) |> 
    ungroup() |> 
    mutate(state = map_lgl({{ identification }}, ~ any(bacteria %in% .x)) + 1) |> 
    select(- {{ identification }}) |> 
    arrange({{ id }}, {{ time_point }})
}
```

A function that selects patients from `x` who have samples from at least 2 time points:

```{r}
select2time_points <- function(x, id) {
  id_with_2obs <- x |> 
    pull({{ id }}) |> 
    table() |> 
    is_greater_than(1) |> 
    which() |> 
    names()
  
  filter(x, {{ id }} %in% id_with_2obs)
}
```

where `id` is the column of `x` that contains the patients IDs. A function that
combines state and time data:

```{r}
state_time <- function(state, time, id, admission, discharge, time_point) {
  time |> 
    mutate("{{discharge}}" := as.numeric({{ discharge }} - {{ admission }}) / 1440,
           "{{admission}}" := 0) |> 
    pivot_longer(- {{ id }},
                 names_to = as_name(enquo(time_point)), values_to = "days") |>
    left_join(x = {{ state }}, y = _,
              c(as_name(enquo(id)), as_name(enquo(time_point))))
}
```

The following function puts the 3 above functions together:

```{r}
msm_data <- function(x, y, id, time_point, identification, bacteria,
                     admission, discharge) {
  x |>
    presence_abscence({{ id }}, {{ time_point }}, {{ identification }}, bacteria) |> 
    select2time_points({{ id }}) |> 
    state_time(y, {{ id }}, {{ admission }}, {{ discharge }}, {{ time_point }})
}
```


## *K. pneumoniae*

### Preparing the data

Generating the presence/absence of *K. pneumoniae*:

```{r eval = FALSE}
K_pneumoniae_raw <- presence_abscence(MALDITOF, USUBJID, SampleSchedule,
                                      Identification_MALDITOF, "Klebsiella pneumoniae")
```

```{r include = FALSE, warning = FALSE}
if (file_exists("K_pneumoniae_raw.rds")) {
  K_pneumoniae_raw <- readRDS2("K_pneumoniae_raw.rds")
} else {
  K_pneumoniae_raw <- presence_abscence(MALDITOF, USUBJID, SampleSchedule,
                                        Identification_MALDITOF,
                                        "Klebsiella pneumoniae")
  saveRDS2(K_pneumoniae_raw, "K_pneumoniae_raw.rds")
}
```

Which gives:

```{r}
K_pneumoniae_raw
```

Not all the patients have both `ADMISSION` and `DISCHARGE`:

```{r}
K_pneumoniae_raw |> 
  pull(USUBJID) |> 
  table() |> 
  table()
```

Selecting the patients that have samples from at least 2 time points:

```{r}
K_pneumoniae <- select2time_points(K_pneumoniae_raw, USUBJID)
```

Making the dataset for the multistate modelling:

```{r}
(Kp_msm <- state_time(K_pneumoniae, dates, USUBJID,
                      ADMISSION, DISCHARGE, SampleSchedule))
```

Alternatively, we can do all at once with this function:

```{r eval = FALSE}
Kp_msm <- msm_data(MALDITOF, dates, USUBJID, SampleSchedule, Identification_MALDITOF,
                   "Klebsiella pneumoniae", ADMISSION, DISCHARGE)
```

```{r include = FALSE, warning = FALSE}
if (file_exists("Kp_msm.rds")) {
  Kp_msm <- readRDS2("Kp_msm.rds")
} else {
  Kp_msm <- msm_data(MALDITOF, dates, USUBJID, SampleSchedule, Identification_MALDITOF,
                     "Klebsiella pneumoniae", ADMISSION, DISCHARGE)
  saveRDS2(Kp_msm, "Kp_msm.rds")
}
```

which gives:

```{r}
Kp_msm
```


### Multi-state modelling

Defining the structure of the $Q$ matrix:

```{r}
Q <- rbind(c(0, 1),
           c(1, 0))
```

Initial values of the $Q$ matrix:

```{r}
(Q_crude <- crudeinits.msm(state ~ days, USUBJID, Q, Kp_msm))
```

Fitting a simple model without any covariate:

```{r}
(Kp_msm_fit <- msm(state ~ days, USUBJID, Kp_msm, Q))
```

Or we call simply do:

```{r}
(Kp_msm_fit <- bsm(state ~ days, USUBJID, Kp_msm))
```

Estimated transition intensity $Q$ matrix:

```{r}
qmatrix.msm(Kp_msm_fit)
```

Estimated transition probability $P$ matrix per day:

```{r}
pmatrix.msm(Kp_msm_fit)
```

Estimated mean sojourn times in each transient state:

```{r}
sojourn.msm(Kp_msm_fit)
```

Log-likelihood of the model:

```{r}
logLik(Kp_msm_fit)
```


#### Bootstrapped CIs

Bootstrapping $Q$ estimates (1000 samples):

```{r eval = FALSE}
q_list <- boot.msm(Kp_msm_fit, function(x) qmatrix.msm(x)$estimates, 1000)
```

```{r include = FALSE, warning = FALSE}
if (file_exists("q_list.rds")) {
  q_list <- readRDS2("q_list.rds")
} else {
  q_list <- boot.msm(Kp_msm_fit, function(x) qmatrix.msm(x)$estimates)
  saveRDS2(q_list, "q_list.rds")
}
```

Reformating the output into an array of dimension 2, 2, and 1000 (i.e. 2 states and
1000 bootstrap samples):

```{r}
q_array <- array(unlist(q_list), dim = c(2, 2, 1000))
```

Or we can simply do instead of the above two successive command lines:

```{r eval = FALSE}
q_array <- boot_msm(Kp_msm_fit, qmatrix.msm, 1000)
```

```{r include = FALSE, warning = FALSE}
if (file_exists("q_array.rds")) {
  q_array <- readRDS2("q_array.rds")
} else {
  q_array <- boot_msm(msm_fit, qmatrix.msm, 1000)
  saveRDS2(q_array, "q_array.rds")
}
```

The bootstrap estimate of the standard deviation:

```{r}
apply(q_array, 1:2, sd)
```

Or, equivalently, in a formatted output:

```{r}
boot_stat(q_array)
```

The bootstrap estimate of the 95% confidence interval:

```{r}
apply(q_array, 1:2, function(x) quantile(x, c(.025, .975)))
```



